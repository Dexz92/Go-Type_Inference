package lang.ast;

import java.util.ArrayList;
import beaver.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
public class LangParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short ID = 1;
		static public final short LP = 2;
		static public final short INTVALUE = 3;
		static public final short BOOLVALUE = 4;
		static public final short FLOAT64VALUE = 5;
		static public final short SEMI = 6;
		static public final short LB = 7;
		static public final short EQ = 8;
		static public final short NE = 9;
		static public final short LE = 10;
		static public final short GE = 11;
		static public final short LT = 12;
		static public final short GT = 13;
		static public final short ADD = 14;
		static public final short SUB = 15;
		static public final short RB = 16;
		static public final short ASSIGN = 17;
		static public final short RP = 18;
		static public final short VAR = 19;
		static public final short CONST = 20;
		static public final short INT = 21;
		static public final short BOOL = 22;
		static public final short FLOAT64 = 23;
		static public final short MUL = 24;
		static public final short DIV = 25;
		static public final short MOD = 26;
		static public final short ELSE = 27;
		static public final short COMMA = 28;
		static public final short FUNC = 29;
		static public final short FOR = 30;
		static public final short IF = 31;
		static public final short SHORTASSIGN = 32;
		static public final short RETURN = 33;

		static public final String[] NAMES = {
			"EOF",
			"ID",
			"LP",
			"INTVALUE",
			"BOOLVALUE",
			"FLOAT64VALUE",
			"SEMI",
			"LB",
			"EQ",
			"NE",
			"LE",
			"GE",
			"LT",
			"GT",
			"ADD",
			"SUB",
			"RB",
			"ASSIGN",
			"RP",
			"VAR",
			"CONST",
			"INT",
			"BOOL",
			"FLOAT64",
			"MUL",
			"DIV",
			"MOD",
			"ELSE",
			"COMMA",
			"FUNC",
			"FOR",
			"IF",
			"SHORTASSIGN",
			"RETURN"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9orbdjGr5KKnx#$NTn5CmMCD40hI4CX1GAib8G8DNjOPYb6bfg9bVcer2oJNcPcslIOh6c" +
		"QifccSSfGAZNJycrg#IeIHIjVKPbMbhqxVN#$FRjxTziVye#xyxddd7lFlUVStVi2h2COZX" +
		"7eZaxeXcAKeoLQuHOyXjCn53VXPlJ7a0YF#t0fhg279#GndfQFLW8IqKRUGYRkm5au7$aem" +
		"32fGs78QWq$of24qv2CEp4Mvo8lDEuP4TOb4TRb4LOv7a5pj7NYsFLdilvgT8w8#WFAv5jK" +
		"uJ8dJZW3spe5BN0Lnicdw8iKd8SBS15wukA86DaHLc$qGQNfAnjngslVmRBJjMq2xefekz$" +
		"LSoQUmAaHhQ5Po2U6PwgXdstCDFQuNL5YM1SQUWz3BpBqNYuvV6peTJ6ZjJUoYQK5$J9Eu7" +
		"VID15SBp#X7RfWbfDDHsPZorpABAwlqRWDjpjhneiupC00J9TZYCUrQAPj$V0WEk0Sv20Dw" +
		"GwbQWVAW5UW37f4KuY1t7CLQ2L7v0lSJVrUCfLKuaeyX6jm7Mx08Do8sRH7OXJ6o1$oE#x1" +
		"H4p2P3853s2Q$CnzyJ0UbQDu4lRdSVcJesSmZy2yChb7kd1U5l#hhlndSpZFl2WFsyhY$nZ" +
		"so69#GQitTxr5x5#Z6VUytx1wKKlalYtb#T26E$p$upRDidW#53jnWlLvNBDcr2J6IU0EBN" +
		"FYX5jioyzLs84dWezx8PwdH0lkzfRSHur5z74iqzV7jU7Urz$ajiOyVPo1sMhEp$GqzR2Fs" +
		"xX9hdtTTBSSJ3rsjB17BAsfVYTF0tFmEwibAvHDKARHAvatLbjdpVJWgLN4ix20wwex#xJN" +
		"DX$FidQybrAu4rix9AaTA0DUWJBe4Otbx3cR98uSr6soENwQimxypdhETtxrH9vD5hy9FA5" +
		"IsP9ApTRjdLR0FjmNmW$z4Zd3ELKigfpDRaqDw$o$mF60mQGlsoPJZjUsvIehWlwnu6S7#q" +
		"rHVIBfHljvod6KCqYsniqbpv52yXGfDdAQoU8WvLYrorZif#n7NYVFaFwDvs4D96#GSZAV3" +
		"2LlaX5a0QbMltZDjHFrIifPMfzCvchRizGtg9v9FPLi91#IfzL$fSfLP0oLUPGfP9FMht7v" +
		"lOQmRIkf9I#GzIxpMQgoZkoYOizZ0cLm7fl9QjLtgjocCHQhlPsiLNqFgI47r7x9Y7M8x2Q" +
		"JQApJkWOodTJRDfVIrzG71VlGFgn#mpHcYTRlDNoEnvgRyLkaHjbBT4oVsZrLhj3w53EcqI" +
		"$Tq8Uht6BCR#G9ygXLMQzodyg6HlgCDlJEiNpitu8YHtEeK3atQfogIDjwiR5SZNwZckAdU" +
		"HobcAtZlwnolX7pbQWSvgciZgfVg79PZ7nUY$9zLUldC8E$oR$o3uoFV4D#90roI0xA0Tal" +
		"##mrnfhjJhcQV42MglyoiaJUaHh7Ma$MabNoFil5iaWMIhMyBGlaFTehoKU4#rLMo79P9sl" +
		"aNHrdirDkSieDKVbyfVekjR#KlR97wcMtrCWYsiTagsoJN#GtEIw$CjQMgFuxf5Qrpq8rds" +
		"lxOVATV1$o$olKTG3VInRVKXw5wvutKn7l9$iDPfDjaEy0lbyi0jvApVdoidWZsO1taPVOj" +
		"u27zuV56yH3m7UN5PDItjkbl0TpgPlaEO3tdPU0hpK$yV6EYIFWIy$BzruSiQM7Rp6BsET$" +
		"75ztNhwwBDZdU0xRCbYNmReI1ujdgjS5YsyDhsBnZFOQMBoJlSGAqT4WdVJv3mzA0Sm=");

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

	private final Action[] actions;

	public LangParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] program = globalList.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					 return new Program(a);
				}
			},
			new Action() {	// [1] globalList = globalList.a functionDeclaration.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final FunctionDeclaration b = (FunctionDeclaration) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [2] globalList = globalList.a globalVariable.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final GlobalVariable b = (GlobalVariable) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [3] globalList = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new List();
				}
			},
			new Action() {	// [4] globalVariable = globalIdentifier.a ASSIGN condition.b SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdentifierDeclaration a = (IdentifierDeclaration) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new GlobalVariable(a, b);
				}
			},
			new Action() {	// [5] globalIdentifier = mutability.c ID.a varType.type
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_c = _symbols[offset + 1];
					final MutableValue c = (MutableValue) _symbol_c.value;
					final Symbol a = _symbols[offset + 2];
					final Symbol _symbol_type = _symbols[offset + 3];
					final Type type = (Type) _symbol_type.value;
					 return new IdentifierDeclaration(type,a, c);
				}
			},
			new Action() {	// [6] mutability = VAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Variable();
				}
			},
			new Action() {	// [7] mutability = CONST
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Constant();
				}
			},
			new Action() {	// [8] type = INT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new IntType();
				}
			},
			new Action() {	// [9] type = BOOL
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new BoolType();
				}
			},
			new Action() {	// [10] type = FLOAT64
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new FloatType();
				}
			},
			Action.RETURN,	// [11] varType = type
			new Action() {	// [12] varType = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new InferredType();
				}
			},
			Action.RETURN,	// [13] funcType = type
			new Action() {	// [14] funcType = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new VoidType();
				}
			},
			new Action() {	// [15] functionDeclaration = FUNC functionIdentifier.a LP functionParameterList.b RP funcType.c LB block.d RB
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final IdentifierDeclaration a = (IdentifierDeclaration) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 6];
					final Type c = (Type) _symbol_c.value;
					final Symbol _symbol_d = _symbols[offset + 8];
					final Block d = (Block) _symbol_d.value;
					 return new FunctionDeclaration(a, b, c, d);
				}
			},
			new Action() {	// [16] functionIdentifier = ID.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new IdentifierDeclaration(new UnknownType(), a, new Constant());
				}
			},
			new Action() {	// [17] functionParameterList = parameterDeclarationList.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					 return a;
				}
			},
			new Action() {	// [18] functionParameterList = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new List();
				}
			},
			new Action() {	// [19] parameterDeclarationList = parameterDeclarationList.a COMMA parameterIdentifier.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final IdentifierDeclaration b = (IdentifierDeclaration) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [20] parameterDeclarationList = parameterIdentifier.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdentifierDeclaration a = (IdentifierDeclaration) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [21] parameterIdentifier = ID.a type.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Type b = (Type) _symbol_b.value;
					 return new IdentifierDeclaration(b, a, new Variable());
				}
			},
			new Action() {	// [22] block = statementList.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					 return new Block(a);
				}
			},
			new Action() {	// [23] statementList = statementList.a statement.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Statement b = (Statement) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [24] statementList = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new List();
				}
			},
			Action.RETURN,	// [25] statement = variableDeclaration
			Action.RETURN,	// [26] statement = assignment
			Action.RETURN,	// [27] statement = return
			Action.RETURN,	// [28] statement = functionCallAsStatement
			Action.RETURN,	// [29] statement = for
			Action.RETURN,	// [30] statement = if
			new Action() {	// [31] for = FOR shortStatement.a forOptCondition.b SEMI forOperation.c LB block.d RB
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Opt a = (Opt) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Opt b = (Opt) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 5];
					final Opt c = (Opt) _symbol_c.value;
					final Symbol _symbol_d = _symbols[offset + 7];
					final Block d = (Block) _symbol_d.value;
					 return new For(a, b, c, d);
				}
			},
			new Action() {	// [32] for = FOR forOptCondition.b LB block.d RB
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b = _symbols[offset + 2];
					final Opt b = (Opt) _symbol_b.value;
					final Symbol _symbol_d = _symbols[offset + 4];
					final Block d = (Block) _symbol_d.value;
					 return new For(new Opt(), b, new Opt(), d);
				}
			},
			new Action() {	// [33] shortStatement = variableDeclaration.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdentifierDeclarationStatement a = (IdentifierDeclarationStatement) _symbol_a.value;
					 return new Opt(a);
				}
			},
			new Action() {	// [34] shortStatement = assignment.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Assignment a = (Assignment) _symbol_a.value;
					 return new Opt(a);
				}
			},
			new Action() {	// [35] shortStatement = functionCallAsStatement.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final FunctionCallAsStatement a = (FunctionCallAsStatement) _symbol_a.value;
					 return new Opt(a);
				}
			},
			new Action() {	// [36] shortStatement = SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Opt();
				}
			},
			new Action() {	// [37] forOptCondition = condition.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					 return new Opt(a);
				}
			},
			new Action() {	// [38] forOptCondition = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Opt();
				}
			},
			new Action() {	// [39] forOperation = identifierUse.a ASSIGN condition.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdentifierUse a = (IdentifierUse) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new Opt(new Assignment(a, b));
				}
			},
			new Action() {	// [40] forOperation = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Opt();
				}
			},
			new Action() {	// [41] if = IF shortStatement.a condition.b LB block.c RB elseBlock.d
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Opt a = (Opt) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 5];
					final Block c = (Block) _symbol_c.value;
					final Symbol _symbol_d = _symbols[offset + 7];
					final Opt d = (Opt) _symbol_d.value;
					 return new If(a, b, c, d);
				}
			},
			new Action() {	// [42] if = IF condition.b LB block.c RB elseBlock.d
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b = _symbols[offset + 2];
					final Expression b = (Expression) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 4];
					final Block c = (Block) _symbol_c.value;
					final Symbol _symbol_d = _symbols[offset + 6];
					final Opt d = (Opt) _symbol_d.value;
					 return new If(new Opt(), b, c, d);
				}
			},
			new Action() {	// [43] elseBlock = ELSE LB block.a RB
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Block a = (Block) _symbol_a.value;
					 return new Opt(a);
				}
			},
			new Action() {	// [44] elseBlock = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Opt();
				}
			},
			new Action() {	// [45] variableDeclaration = variableIdentifier.a initialValue.b SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdentifierDeclaration a = (IdentifierDeclaration) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Expression b = (Expression) _symbol_b.value;
					
		Expression val = b;

		if (b instanceof NullValue) {
			if (a.getMutabilityStatus() instanceof Constant) {
				return new IdentifierDeclarationStatement(a, new Opt());
			}
			if (a.getType() instanceof IntType) {
				val = new Int(new IntType(),"0");
			} else if (a.getType() instanceof BoolType) {
				val = new Bool(new BoolType(),"false");
			} else if (a.getType() instanceof FloatType) {
				val = new Float64(new FloatType(),"0.000000");
			}
		}
		return new IdentifierDeclarationStatement(a, new Opt(val));
				}
			},
			new Action() {	// [46] variableIdentifier = mutability.c ID.a varType.b ASSIGN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_c = _symbols[offset + 1];
					final MutableValue c = (MutableValue) _symbol_c.value;
					final Symbol a = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Type b = (Type) _symbol_b.value;
					 return new IdentifierDeclaration(b, a, c);
				}
			},
			new Action() {	// [47] variableIdentifier = mutability.c ID.a varType.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_c = _symbols[offset + 1];
					final MutableValue c = (MutableValue) _symbol_c.value;
					final Symbol a = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Type b = (Type) _symbol_b.value;
					 return new IdentifierDeclaration(b, a, c);
				}
			},
			new Action() {	// [48] variableIdentifier = ID.a SHORTASSIGN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new IdentifierDeclaration(new InferredType(), a, new Variable());
				}
			},
			new Action() {	// [49] initialValue = condition.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					 return a;
				}
			},
			new Action() {	// [50] initialValue = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NullValue(new UnknownType(),"null");
				}
			},
			new Action() {	// [51] assignment = identifierUse.a ASSIGN condition.b SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdentifierUse a = (IdentifierUse) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new Assignment(a,b);
				}
			},
			new Action() {	// [52] return = RETURN returnCondition.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Opt a = (Opt) _symbol_a.value;
					 return new Return(a);
				}
			},
			new Action() {	// [53] returnCondition = condition.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					 return new Opt(a);
				}
			},
			new Action() {	// [54] returnCondition = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Opt();
				}
			},
			new Action() {	// [55] functionCallAsStatement = functionCallAsExpression.a SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final FunctionCallAsExpression a = (FunctionCallAsExpression) _symbol_a.value;
					 return new FunctionCallAsStatement(a);
				}
			},
			new Action() {	// [56] functionCallAsExpression = identifierUse.a LP argumentList.b RP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdentifierUse a = (IdentifierUse) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final List b = (List) _symbol_b.value;
					 return new FunctionCallAsExpression(new InferredType(),a,b);
				}
			},
			new Action() {	// [57] functionCallAsExpression = identifierUse.a LP RP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdentifierUse a = (IdentifierUse) _symbol_a.value;
					 return new FunctionCallAsExpression(new InferredType(),a,new List());
				}
			},
			new Action() {	// [58] argumentList = argumentList.a COMMA condition.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return a.add(b);
				}
			},
			new Action() {	// [59] argumentList = condition.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					 return new List().add(a);
				}
			},
			new Action() {	// [60] condition = condition.a EQ exprValue.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new Equal(new BoolType(),a,b);
				}
			},
			new Action() {	// [61] condition = condition.a NE exprValue.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new NotEqual(new BoolType(),a,b);
				}
			},
			new Action() {	// [62] condition = condition.a LE exprValue.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new LessEqual(new BoolType(),a,b);
				}
			},
			new Action() {	// [63] condition = condition.a GE exprValue.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new GreaterEqual(new BoolType(),a,b);
				}
			},
			new Action() {	// [64] condition = condition.a LT exprValue.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new Lesser(new BoolType(),a,b);
				}
			},
			new Action() {	// [65] condition = condition.a GT exprValue.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new Greater(new BoolType(),a,b);
				}
			},
			Action.RETURN,	// [66] condition = exprValue
			new Action() {	// [67] exprValue = exprValue.a ADD term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new Add(new InferredType(),a,b);
				}
			},
			new Action() {	// [68] exprValue = exprValue.a SUB term.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new Sub(new InferredType(),a,b);
				}
			},
			Action.RETURN,	// [69] exprValue = term
			new Action() {	// [70] term = term.a MUL factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new Mul(new InferredType(),a,b);
				}
			},
			new Action() {	// [71] term = term.a DIV factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new Div(new InferredType(),a,b);
				}
			},
			new Action() {	// [72] term = term.a MOD factor.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new Mod(new InferredType(),a,b);
				}
			},
			Action.RETURN,	// [73] term = factor
			RETURN3,	// [74] factor = LP exprValue RP; returns 'RP' although none is marked
			Action.RETURN,	// [75] factor = value
			Action.RETURN,	// [76] factor = identifierUse
			Action.RETURN,	// [77] factor = functionCallAsExpression
			new Action() {	// [78] value = INTVALUE.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new Int(new IntType(),a);
				}
			},
			new Action() {	// [79] value = BOOLVALUE.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new Bool(new BoolType(),a);
				}
			},
			new Action() {	// [80] value = FLOAT64VALUE.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new Float64(new FloatType(),a);
				}
			},
			new Action() {	// [81] identifierUse = ID.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new IdentifierUse(new InferredType(),a);
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
